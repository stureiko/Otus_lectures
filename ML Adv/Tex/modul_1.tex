\chapter{Модуль 1. Advanced Machine Learning. AutoML.}
\section{Production Code проекта на примере задачи классификации/регрессии, Virtual environments, dependency management, pypi/gemfury.}
\subsection{О чем этот курс и что в нем будет.}
Описание курса

\subsection{Для чего Data Scientist должен знать, как писать хороший код}
Одним из важных недооцененных навыков для data scientist'a является программирование. Распространено мнение, что анализ данных и построение моделей сводятся к библиотечным вызовам, для которых особой квалификации в написании кода не нужно. Но все становится сложнее когда что-то перестает работать.

Еще одним существенным вопросом становится коммуникация с командой. Когда код, написанный Data Scientist'ом необходимо передавать в пайплайн или (о боже, не дай пропасть) в продакшн код и ветку со страшным названием RC - <<release candidate>>.

Конечно в этом месте можно кивнуть в сторону старшего товарища, носящего гордое звание тимлида - вот он то и ответственен за все происходящее, но стоит понимать что он вам за такое отношение спасибо не скажет.

\subsection{Основные принципы и подходы в написании кода}
Мы конечно не develop но основные принципы написания устойчивого и чистого кода знать должны. 

Итак Литература - классика жанра:

\begin{itemize}
	\item "Чистый Код" Роберт Мартин \href{https://drive.google.com/file/d/17FB3zrdbIRuGB2kldV6aTbhxV7MUbpge/view?usp=share_link}{\underline{link}}
	\item "Совершенный код" Макконнелл Стив \href{https://drive.google.com/file/d/1IP00THrVip-Fp5eY_vu5nvYkAEPZGEWl/view?usp=share_link}{\underline{link}}
\end{itemize}

Рекомендую к прочтению.

Всегда задумывайся о том как можно сделать твой код проще, чище и читабельнее:

\begin{itemize}
	\item Какие кейсы могут быть у задачи?
	\item Все ли я учел?
	\item Что может пойти не так?
	\item Что можно объединить?
	\item Есть ли похожий функционал?
	\item Что тут лишнее?
	\item Как сделать проще?
	\item Как сделать читабельнее?
	\item Как сделать понятнее?
\end{itemize}

\textbf{И всегда помни - если ты сделал копи-паст или написал блок кода более одного раза - значит твой код нуждается в улучшении.}

\subsubsection{Несколько отличительных признаков чистого кода}

\begin{itemize}
	\item Сфокусированность. Каждая функция, класс или модуль выполняют какую-то одну задачу, причем хорошо.
	\item Читабельность. Как сказал Грэйди Буч, автор книги «Object-Oriented Analysis and Design with Applications», чистый код читается, как хорошо написанная проза.
	\item Легкость отладки.
	\item Легкость поддержки. Если код чистый, другие разработчики без проблем смогут его читать и улучшать.
	\item Высокая производительность.
\end{itemize}

\subsubsection{Наименования и разделения}

\begin{itemize}
	\item Используй понятные и удобнопроизносимые имена для любых сущностей. Они должны описывать почему эта сущность существует, что она делает и как используется.
	\item Не бойся тратить время на выбор лучшего и понятного имени. Ты выиграешь в будущем при работе или чтении этого кода.
	\item Если название сущности не соответствует еë функционалу или по названию не понятно, что сущность делает, то еë надо переименовать в самое понятное название. Если этого сделать невозможно, то значит с еë функционалом что-то не так и еë надо рефакторить.
	\item Сущность, которая имеет в названии "And", "With" — нарушает Single Responsibility. Функционал такой сущности стоит разделять. Но этим правилом стоит иногда пренебрегать.
	\item Непонятные тексты, строки стоит выносить в переменные и давать им понятные названия.
	\item Названия методов должны содержать глагол, который описывает, что этот метод делает и ключевое слово с которым работает данный метод. Если в названии метода нет глагола, то эта сущность не должна быть методом или ему нужно дать правильное название.
	\item Нужно избегать одинаковых наименований для двух разных целей.
	\item Если сущность имеет схожее с другой сущностью название, то скорее всего их функционал очень сильно похож и их нужно объединить? Если нет, то их названия нужно менять так, чтобы они не были похожими.
	\item Если ты мысленно переименовываешь сущность, когда читаешь код, чтобы тебе было понятнее понимать её функционал, то переименуй её в это мысленное название.
	\item Выбери одно слово для одной концепции. Сложно будет понимать функционал, когда у тебя есть fetch, retrieve и get в названиях. Пусть лучше везде будет get.
	\item Длинное и понятное имя лучше, чем короткое, но непонятное.
	\item Придерживайся PEP8
\end{itemize}

\subsubsection{Функции}

\begin{itemize}
	\item Функции должны быть короткими и компактными.
	\item Функции должны быть очень короткими и очень компактными.
	\item Приблизительный максимум 20 строк и 150 символов в одной строке, если не влезает, то нужно разделять.
	\item Функция должна выполнять только одну операцию.
	\item Она должна выполнять её хорошо и ничего другого она делать не должна.
	\item Если функция выполняет только те действия, которые находятся на одном уровне абстракции, то функция выполняет одну операцию.
	\item Чтобы определить выполняет ли функция более одной операции, попробуй извлечь из нее другую функцию, которая не будет являться простой переформулировкой реализации.
	\item Любые условные операторы с длинными выборами через switch-case, if-else должны разделяться или объединяться без дублирования, возможно на классы с реализациями, а выбор реализации передать базовому классу, фабрике или еще кому-то.
	\item If, else, while и т.д. должны содержать вызов одной функции. Так будет читабельнее, понятнее и проще.
	\item Идеальное количество входных аргументов для функции = 0. Если входных аргументов больше трех, то стоит задуматься каким образом лучше от них избавиться, например, создать класс для этих аргументов.
	\item Чем больше входных аргументов, тем тяжелее понимается функция.
	\item Функция в которую передается аргумент-флаг, от которого зависит работа функции говорит о том, что функция выполняет более одной операции. Такие функции следует разбить на две и вызывать их уровнем выше.
	\item Функция, которая изменяет входной аргумент, должна отдавать ссылку на измененный объект, а не просто изменять без возврата. String transform(String text)
	\item Если функция, должна изменять входной аргумент, то пусть она изменяет состояние своего объекта-владельца.
	\item Если входной аргумент функции не должен меняться (и используется дальше в коде), то следует скопировать значение аргумента и внутри функции работать с копией.
	\item Вместо return null лучше использовать пустой объект — Collection.empty() или null-объект -EmptyObject().
	\item Всегда старайся использовать нестатические функции. Если это невозможно, то используй статические.
	\item Если есть код, который должен следовать один за другим, то передавай результаты первой функции во вторую, чтобы кто-нибудь не изменил последовательность вызовов.
	\item Используй полиморфизм вместо if/else или switch/case или when.
	\item Избегай отрицательных условий.
\end{itemize}

\subsubsection{Комментарии}

\begin{itemize}
	\item Не используй комментарии, если ты можешь использовать функцию или переменную вместо этого.
	\item Не комментируй плохой код — перепиши его. Не стоит объяснять, что происходит в плохом коде, лучше сделать его явным и понятным.
	\item Комментарии можно использовать для передачи какой-то информации, предупреждения о последствиях, но не для объяснения того, как работает код.
	\item Используй TODO и FIXME в тех случаях, когда нужно пометить, что код нуждается в доработке, но сейчас нет ресурсов на это.
	\item Используй //region REGIONNAME //endregion REGIONNAME, а если используешь, то подумай можно ли разделить region на сущности.
	\item Документируй код, который является сложным, но чистым.
	\item Не оставляй старый закомментированный код. Ты можешь найти его в истории коммитов, если необходимо.
	\item Комментарии должны быть краткими и понятными. В комментариях с информацией не должно быть много информации. Все должно быть кратко и по делу.
\end{itemize}

\subsubsection{Документация}

\begin{itemize}
	\item Через два дня ты забудешь что делает твой код. Пиши DocString
	\item В идеале каждый твой класс и функция должна нести в себе DocString. Это поможет собрать документацию для всей системы.
	\item Начинай модификацию кода с DocString теста. Затем переходи к самй функции и классу. Тогда после успешного прохождения тестов у тебя будет актуальная документация.
\end{itemize}

\subsubsection{Форматирование и правила}

\begin{itemize}
	\item Соблюдай codestyle, принятый на проекте.
	\item Соблюдай правила, принятые в команде.
	\item При соблюдении форматирования и codestyle код будет читаться проще и лучше. Ведь не зря книгу отдают на редакцию, перед тем, как её издавать.
	\item Нужно иметь автоматические средства, которые будут форматировать код за тебя.
	\item Файл с исходным кодом должен быть как газетная статья. Есть заголовок, краткое описание в виде параметров и содержание в виде функций. Если это не так, то стоит изменить форматирование.
	\item Сущности, связанные друг с другом, должны находиться рядом, например, в одном package, чтобы было проще навигировать по коду.
	\item Переменные(поля) класса должны находиться вверху класса.
	\item Переменные методов должны находиться ближе к своему месту использования.
	\item Функции должны находиться в порядке вызова. Если одна вызывает другую, то вызывающая функция должна находиться над вызываемой. C другой стороны, приватные функции более низкого уровня могут находиться внизу файла и не мешать пониманию кода высокого уровня. Но я предпочитаю первый способ.
\end{itemize}

\subsubsection{Объекты и структуры данных}

\begin{itemize}
	\item Ты должен работать с абстракциями, чтобы реализацию можно было легко изменить.
	\item Ты должен работать с абстракциями, потому что клиент, использующий функционал, не должен знать о деталях реализации, он должен знать какую реализацию в каком случае использовать.
	\item Ты должен предоставлять API, с которым стоит работать и скрывать детали реализации, структуру. Так будет проще работать с такими сущностями и добавлять новые виды поведений, функционала и реализаций.
	\item DTO — Data Transfer Object. Класс, который содержит только данные и никакого функционала. Нужен для того, чтобы передавать какие-то данные. Объект такого класса должен быть неизменяемым.
\end{itemize}

\subsubsection{Классы}

\begin{itemize}
	\item Классы должны быть компактными.
	\item Классы должны быть еще компактнее.
	\item Имя класса должно описывать его ответственности. Отсюда можно и вычислить размер класса.
	\item Функционал класса должен четко соответствовать и вписываться в название класса.
	\item Разделяй связанность на маленькие классы. Жесткой и обильной связанности не должно быть — это усложняет поддержку и развитие проекта.
	\item Помни о Single Responsibility. Сущность должна иметь одну и только одну причину для изменения.
	\item Соблюдай инкапсуляцию. Ослабление инкапсуляции всегда должно быть последней мерой.
	\item Обычно мы объявляем переменные и вспомогательные функции приватными, но иногда их нужно объявлять protected и иметь возможность обратиться к ней из теста.
	\item Если группа функций относится к определенному функционалу, то эту группу функций можно и нужно выделить в отдельный класс и использовать его экземпляр.
\end{itemize}

\subsubsection{Архитектура}

\begin{itemize}
	\item Паттерны программирования. До нас много умных людей билось над решением таких же задач и набивало свои шишки. Они создали наиболее устойчивые и чистые решения - их стоит знать.
	\item Не нужно злоупотреблять паттернами. Помни, если что-то можно сделать просто, то не нужно плодить сущности и усложнять процесс. Но для наиболее часто встречающихся операций есть два десятка основных паттернов которые стоит знать.
	\item Помните о декораторах. Зачастую использовав декоратор можно отказаться от класса.
	\item Многопоточность. Python не заточен для работы с многопоточностью и она реализуется отдельными библиотеками и фреймворками. Так же в многопоточной программе гораздо сложнее отлаживать ошибки. Всегда оцени сколько ты сможешь выиграть производительности.
	\item Библиотеки и фреймворки. Если для реализации твоей задачи есть готовая библиотека - всегда используй ее. Не нужно писать свой алгоритм сортировки, хотя тебя и учили этому на всех курсах по программированию. Твой код необходимо покрыть тестами, проверить на нестандартное поведение, убедиться что из него не утекает память и еще множество вещей. Все это уже сделано автором библиотеки и проверено ее аудиторией. Чем она больше - тем меньше вероятность возникновения ошибок. Помни - твой тимлид предпочтет надежный легко понятный стандартный код нежели полет математической мысли с которым не понятно что потом делать.
\end{itemize}

\subsubsection{Обработка ошибок}

\begin{itemize}
	\item Используй Exceptions вместо возвращения кодов ошибок.
	\item Обработка ошибок — это одна операция. Если в функции есть ключевое слово try, то после блоков catch/finally ничего другого в функции быть не должно.
	\item Если у тебя есть enum, который перечисляет ошибки, то от него лучше избавиться и вместо него использовать исключения.
	\item Используй unchecked exceptions, чтобы явно указать на место в котором есть проблемы. Такие ошибки не нужно отлавливать, вместо этого нужно написать код так, чтобы этой ошибки никогда не было.
	\item Передавай достаточное количество информации вместе с выбросом исключения, чтобы потом пользователи твоего кода могли понять, что же действительно произошло.
	\item Вместо условных операторов с обработкой ошибок лучше выбрасывать исключения и обрабатывать их.
	\item Не передавай null куда-либо. Старайся этого максимально избежать.
	\item Обработка ошибок — это отдельная задача и не относится к основной логике программы.
	\item Логирование. Всегда добавляйте логирование. Это не пустая трата времени, когда программа упадет в пайплайне разобраться в произошедшем будет крайне не просто.
	\item Тестирование. Хороший код покрыт тестами. Все части кода покрыты юнит тестами. И сверху он покрыт интеграционным тестом, который проверяет взаимодействие частей и логику программы.
\end{itemize}

\subsubsection{Границы}

\begin{itemize}
	\item Мы всегда используем какие-либо библиотеки, которые чаще всего дают нам слишком широкий, слишком маленький функционал или конфликтуют с ожидаемым функционалом, что делает код грязнее в его конечном использовании. Избежать этого можно просто применив паттерны типа Decorator, Adapter, Facade или другие.
	\item Бывают ситуации, когда тебе нужно работать с функционалом, который находится в разработке или пока что не адаптирован для использования в продакшен коде. В этом случае стоит представить чего ты ждешь от библиотеки/этого функционала и написать свой интерфейс или создать сущность с которыми ты будешь работать в своем проекте так, как тебе нужно. Когда библиотека доделается и станет стабильной, ты адаптируешь её под свои готовые структуры и использовать уже готовый функционал.
\end{itemize}

\subsection{Основная структура ML проекта на Python}
\subsubsection{Общие принципы организации проекта}
\begin{itemize}
	\item Используйте виртуальное окружение для каждого проекта. Это очистит память и упростит формирование зависимостей проекта. \linebreak Эволюция: \href{https://virtualenv.pypa.io/en/latest/}{\underline{Virtualenv}} $\to$ \href{https://pipenv.pypa.io/en/latest/}{\underline{Pipenv}} $\to$ \href{https://python-poetry.org}{\underline{Poetry}}.
	\item Уберите из репозитория ненужные файлы. Используйте адекватный .gitignore
	\item Не храните в коде секретные данные. Используйте для этого ssh авторизацию. Или переместите эти данные в отдельные файлы. Да - и не забудьте добавить их в .gitignore
	\item Добавьте в проект файл README. В проекте, на его верхнем уровне, должен присутствовать файл README, в котором описана цель создания проекта, даются инструкции по установке проекта и по началу работы с ним.
\end{itemize}

\subsubsection{Шаблон ML проекта}
\begin{itemize}
	\item создать читаемую структуру проекта;
	\item эффективно управлять зависимостями в проекте;
	\item создавать короткие и читаемые команды для повторяемых задач;
	\item перезапускать только модифицированные компоненты конвейера данных;
	\item Наблюдать и автоматизировать код;
	\item включить подсказки типов во время исполнения кода;
	\item проверять проблемы в коде перед фиксацией изменений (перед коммитом);
	\item автоматически документировать код;
	\item автоматически запускать тесты при коммите.
\end{itemize}

\subsubsection{Инструменты}

\begin{itemize}
	\item \href{https://python-poetry.org/}{\underline{Poetry}} - управление зависимостями Python
	\item \href{https://www.prefect.io/}{\underline{Prefect}} - упорядочение и просмотр конвейера данных
	\item \href{https://docs.pydantic.dev/}{\underline{Pydantic}} - валидация данных с помощью аннотаций типа в Python
	\item \href{https://pre-commit.com/}{\underline{pre-commit plugins}} - форматирование, тестирование и документирование кода согласно лучшим практикам
	\item \href{https://makefiletutorial.com}{\underline{Makefile}} - автоматизация повторяемых задач короткими командами
	\item \href{https://docs.github.com/en/actions}{\underline{GitHub Actions}} - автоматизация конвейера непрерывной интеграции и непрерывного развёртывания приложений (CI/CD)
	\item \href{https://github.com/pdoc3/pdoc}{\underline{pdoc}} - автоматическое документирование для API вашего проекта
\end{itemize}

\subsubsection{Структура проекта}

Ниже в общих чертах представлена структура проекта, которой мы будем по возможности придерживаться в данном курсе

\begin{verbatim}

|-- data                       # содержит данные
|   |-- final                  # данные после тренировки модели
|   |-- processed              # данные после обработки
|   |-- raw                    # сырые данные
|   |-- external               # внешние данные
|-- docs                       # документация проекта
|-- .flake8                    # конфигурация инструмента форматирования
|-- .gitignore                 # игнорируемые при коммите в Git файлы
|-- Makefile                   # хранит команды настройки среды
|-- models                     # хранит файлы модели
|-- .pre-commit-config.yaml    # конфигурация pre-commit
|-- pyproject.toml             # зависимости poetry
|-- README.md                  # описание проекта
|-- src                        # хранит исходники
|   |-- __init__.py            # делает src модулем Python
|   |-- config.py              # хранит конфигурации 
|   |-- data                   # хранит скрипты предобработки данных
|   |   |-- process.py         # обрабатывает данные перед обучением модели
|   |-- notebooks              # хранит ноутбуки для EDA и экспериментов
|   |   |-- run_notebook.py    # выполняет блокноты
|   |-- models                 # хранит скрипты для тренировки моделей
|   |   |-- train_model.py     # тренирует модель
|   |-- visualisation         # визуализация результатов
|   |   |-- visualisation.py   # скрипт подготовки дашборда и иной визуализации
+-- tests                      # хранит тесты
    |-- __init__.py            # делает tests модулем Python 
    |-- test_process.py        # тестирует функции в process.py
    |--  test_train_model.py   # тестирует функции в train_model.py 
\end{verbatim}

\begin{forest}
	for tree={
		font=\ttfamily,
		grow'=0,
		child anchor=west,
		parent anchor=south,
		anchor=west,
		calign=first,
		inner xsep=7pt,
		edge path={
			\noexpand\path [draw, \forestoption{edge}]
			(!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
		},
		% style for your file node 
		file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
				(!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
			inner xsep=2pt,font=\small\ttfamily
		},
		before typesetting nodes={
			if n=1
			{insert before={[,phantom]}}
			{}
		},
		fit=band,
		before computing xy={l=15pt},
	}  
	[system
	[config
	]
	[lib: libs
	[Access: any files
	]
	[Plugin
	]
	[file.txt,file
	]
	]
	[templates
	]
	[tests
	]
	]
\end{forest}



